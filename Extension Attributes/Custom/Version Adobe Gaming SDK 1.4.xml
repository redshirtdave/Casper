<?xml version="1.0" encoding="UTF-8"?>
<extensionAttribute>
<displayName>Version Adobe Gaming SDK 1.4</displayName>
<description>Determines if the Adobe Gaming SDK is at least a specified Version by searching for bundles with a specific CFBundleIdentifier and reading the VersionInfo.txt in the bundle's parent folder.</description>
<dataType>string</dataType>
<scriptContentsMac>#!/usr/bin/python&#13;
&#13;
"""&#13;
Determines if the Adobe Gaming SDK is at least a specified Version by searching for bundles with a specific CFBundleIdentifier and reading the VersionInfo.txt in the bundle's parent folder.&#13;
Version infotmation is read from a text file (VersionInfo.txt) in the bundle's parent directory.&#13;
Results may (optionally) be limited to a range, when the CFBundleIdentifier is used for multiple major releases of the product.&#13;
A default path for the bundle may (optionally) be explicitly specified to check.&#13;
Returns 'Older' if an older version of the product is found.&#13;
Returns 'Equal' if the same version of a product is found.&#13;
Returns 'Newer' if a newer version of the product is found.&#13;
Returns 'N/A' if the product is not found.&#13;
"""&#13;
&#13;
# CFBundleIdentifier to search for [required]&#13;
CFBundleIdentifier = 'com.apple.ScriptEditor.id.Install-AwayBuilder'&#13;
# Version to test for [required]&#13;
Version = '1.4.394'&#13;
# Range limit for bundle version [optional]&#13;
Range = ['1.4', '1.5']&#13;
# Default path for bundle [recommended]&#13;
Default = '/Applications/Adobe Gaming SDK 1.4'&#13;
&#13;
# Required modules&#13;
from os import devnull&#13;
from os.path import dirname, exists, isabs, isfile&#13;
from pkg_resources import parse_version&#13;
from re import sub&#13;
from subprocess import check_output&#13;
&#13;
# Read Version from VersionInfo text file&#13;
def read_versioninfo(f):&#13;
	v = open(f).read().splitlines()[0]&#13;
	return v&#13;
&#13;
# Rationalise Version String&#13;
def rationalise_version(v):&#13;
	# Convert to lowercase&#13;
	v = v.lower()&#13;
	# Remove leading non-numeric characters&#13;
	v = sub('^[^0-9]*', '', v)&#13;
	# Remove trailing spaces&#13;
	v = sub(' *$', '', v)&#13;
	# Replace commas with periods&#13;
	v = sub(',', '.', v)&#13;
	# Remove 'dodgy' characters&#13;
	v = sub('[^a-z0-9 .-]', '', v)&#13;
	return v&#13;
&#13;
# Compare Version Strings&#13;
def compare_versions(v1, v2):&#13;
	if (parse_version(v1) &lt; parse_version(v2)):&#13;
		r = 'Older'&#13;
	elif (parse_version(v1) == parse_version(v2)):&#13;
		r = 'Equal'&#13;
	elif (parse_version(v1) &gt; parse_version(v2)):&#13;
		r = 'Newer'&#13;
	return r&#13;
&#13;
# Version in Range&#13;
def version_in_range(v, r):&#13;
	r = parse_version(r[1]) &gt; parse_version(v) &gt;= parse_version(r[0])&#13;
	return r&#13;
&#13;
# Find Bundles with identifier&#13;
def find_bundles(id):&#13;
	r = check_output(['/usr/bin/mdfind', 'kMDItemCFBundleIdentifier', '=', '"' + id + '"']).strip().split('\n')&#13;
	r = filter(lambda a: a != '', r)&#13;
	return r&#13;
&#13;
# Initialise variables&#13;
try:&#13;
	CFBundleIdentifier&#13;
except:&#13;
	print '&lt;result&gt;Error: CFBundleIdentifier not defined&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Version&#13;
except:&#13;
	print '&lt;result&gt;Error: No Version specified&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Range&#13;
except:&#13;
	Range = None&#13;
try:&#13;
	Default&#13;
except:&#13;
	Default = None&#13;
&#13;
&#13;
# Validate Version&#13;
Version = rationalise_version(Version)&#13;
if (Version == ''):&#13;
	print '&lt;result&gt;Error: Version is invalid&lt;/result&gt;'&#13;
	exit(1)&#13;
&#13;
# Validate Range&#13;
if (Range):&#13;
	if (len(Range) != 2):&#13;
		print '&lt;result&gt;Error: Range requires two values&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		Range[0] = rationalise_version(Range[0])&#13;
		if (Range[0] == ''):&#13;
			print '&lt;result&gt;Error: Range minimum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		Range[1] = rationalise_version(Range[1])&#13;
		if (Range[1] == ''):&#13;
			print '&lt;result&gt;Error: Range maximum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (compare_versions(Range[0], Range[1]) != 'Older'):&#13;
			print '&lt;result&gt;Error: Range minimum is greater than maximum&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (version_in_range(Version, Range) == False):&#13;
			print '&lt;result&gt;Error: Version is not within Range&lt;/result&gt;'&#13;
			exit(1)&#13;
&#13;
# Validate Default&#13;
if (Default):&#13;
	if (not isabs(Default)):&#13;
		print '&lt;result&gt;Error: Default path is invalid&lt;/result&gt;'&#13;
		exit(1)&#13;
&#13;
# Initialise array for Folders&#13;
Folders = []&#13;
# Test Default path, add bundle to array if it exists&#13;
if (Default):&#13;
	if (exists(Default)): Folders.append(Default)&#13;
# Search for bundles and add parent folder to array&#13;
for Bundle in find_bundles(CFBundleIdentifier):&#13;
	if (not dirname(Bundle) in Folders): Folders.append(dirname(Bundle))&#13;
&#13;
# If we have no results check Spotlight status&#13;
if (len(Folders) == 0):&#13;
	mdStatus = check_output(['/usr/bin/mdutil', '-s', '/'])&#13;
	# If Spotlight is disabled exit here to avoid a false result&#13;
	if 'disabled' in mdStatus:&#13;
		print '&lt;result&gt;Error: Spotlight is disabled&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		print '&lt;result&gt;N/A&lt;/result&gt;'&#13;
		exit(0)&#13;
else:&#13;
	# Initialise array for VersionInfo files&#13;
	VersionInfo = []&#13;
	# Check default location for VersionInfo file in folder(s)&#13;
	for Folder in Folders:&#13;
		if (isfile(Folder + '/VersionInfo.txt')):&#13;
			VersionInfo.append(Folder + '/VersionInfo.txt')&#13;
	# If no VersionInfo file(s), exit here&#13;
	if (len(Plists) == 0):&#13;
		print '&lt;result&gt;Error: VersionInfo.txt not in folder(s)&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		# Initialise array for Results&#13;
		Results = []&#13;
		# Check version in VersionInfo file(s)&#13;
		for i, File in enumerate(VersionInfo):&#13;
			# Read version from VersionInfo&#13;
			Installed = read_versioninfo(File)&#13;
			# Rationalise the version string for comparison&#13;
			Installed = rationalise_version(Installed)&#13;
			if (Installed == ''):&#13;
				# If we get an empty string for the version add error message&#13;
				Results.append('Error: Reading installed version')&#13;
			else:&#13;
				# Compare our versions and append to array&#13;
				Results.append(compare_versions(Installed, Version))&#13;
				if (Range):&#13;
					# If the installed version is outside of the range, update the entry in the array&#13;
					if (version_in_range(Installed, Range) == False):&#13;
						Results[i] = 'N/A'&#13;
&#13;
		# Prioritise our results&#13;
		if (len(Results) == 1):&#13;
			Result = Results[0]&#13;
		elif ('Newer' in Results):&#13;
			Result = 'Newer'&#13;
		elif ('Equal' in Results):&#13;
			Result = 'Equal'&#13;
		elif ('Older' in Results):&#13;
			Result = 'Older'&#13;
		elif ('N/A' in Results):&#13;
			Result = 'N/A'&#13;
		else:&#13;
			Result = 'Error: Reading installed version'&#13;
&#13;
		# Output final result&#13;
		print '&lt;result&gt;' + Result + '&lt;/result&gt;'&#13;
		exit(0)</scriptContentsMac>
<scriptContentsWindows/>
</extensionAttribute>
