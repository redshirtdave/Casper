<?xml version="1.0" encoding="UTF-8"?>
<extensionAttribute>
<displayName>Version Adobe Muse CC</displayName>
<description>Determines if an Adobe product is at least a specified Version by querying the pdb.db database for a productName and payloadName.</description>
<dataType>string</dataType>
<scriptContentsMac>#!/usr/bin/python&#13;
&#13;
"""&#13;
Determines if an Adobe product is at least a specified Version by querying the pdb.db database for a productName and payloadName.&#13;
Results may (optionally) be limited to a range of versions when the productName is not unique.&#13;
Returns 'Older' if an older version of the product is found.&#13;
Returns 'Equal' if the same version of a product is found.&#13;
Returns 'Newer' if a newer version of the product is found.&#13;
Returns 'N/A' if the product is not found.&#13;
"""&#13;
&#13;
# productName in database to search for [required]&#13;
productName = 'Adobe Muse'&#13;
# payloadName for product [optional]&#13;
# payloadName = 'PAYLOAD'&#13;
# Version to test for [required]&#13;
Version = '7.4'&#13;
# Range limit for product version [optional]&#13;
# Range = ['MIN', 'MAX']&#13;
# Path to pdb.db database containing installed product information [required]&#13;
pdb = '/Library/Application Support/Adobe/caps/pdb.db'&#13;
&#13;
# Required modules&#13;
from sqlite3 import connect&#13;
from os.path import isfile&#13;
from pkg_resources import parse_version&#13;
from re import sub&#13;
&#13;
# Search for productName in pdb&#13;
def query_db_product(db, product, payload):&#13;
	c = connect(db).cursor()&#13;
	try:&#13;
		c.execute('SELECT version FROM payloads WHERE productName LIKE "' + product \&#13;
					+ '" OR productName LIKE "' + product + '_%_' + str(payload) + '"')&#13;
		q = c.fetchall()&#13;
		connect(db).close()&#13;
	except:&#13;
		q = None&#13;
	r = []&#13;
	if (q):&#13;
		for i in q:&#13;
			r.append(i[0].encode('ascii','ignore'))&#13;
	return r&#13;
&#13;
# Rationalise Version String&#13;
def rationalise_version(v):&#13;
	# Convert to lowercase&#13;
	v = v.lower()&#13;
	# Remove leading non-numeric characters&#13;
	v = sub('^[^0-9]*', '', v)&#13;
	# Remove trailing spaces&#13;
	v = sub(' *$', '', v)&#13;
	# Replace commas with periods&#13;
	v = sub(',', '.', v)&#13;
	# Remove 'dodgy' characters&#13;
	v = sub('[^a-z0-9 .-]', '', v)&#13;
	return v&#13;
&#13;
# Compare Version Strings&#13;
def compare_versions(v1, v2):&#13;
	if (parse_version(v1) &lt; parse_version(v2)):&#13;
		r = 'Older'&#13;
	elif (parse_version(v1) == parse_version(v2)):&#13;
		r = 'Equal'&#13;
	elif (parse_version(v1) &gt; parse_version(v2)):&#13;
		r = 'Newer'&#13;
	return r&#13;
&#13;
# Version in Range&#13;
def version_in_range(v, r):&#13;
	r = parse_version(r[1]) &gt; parse_version(v) &gt;= parse_version(r[0])&#13;
	return r&#13;
&#13;
# Initialise variables&#13;
try:&#13;
	productName&#13;
except:&#13;
	print '&lt;result&gt;Error: productName not defined&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	payloadName&#13;
except:&#13;
	payloadName = None&#13;
try:&#13;
	Version&#13;
except:&#13;
	print '&lt;result&gt;Error: No Version specified&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Range&#13;
except:&#13;
	Range = None&#13;
try:&#13;
	pdb&#13;
except:&#13;
	print '&lt;result&gt;Error: pdb not defined&lt;/result&gt;'&#13;
	exit(1)&#13;
&#13;
# Validate Version&#13;
Version = rationalise_version(Version)&#13;
if (Version == ''):&#13;
	print '&lt;result&gt;Error: Version is invalid&lt;/result&gt;'&#13;
	exit(1)&#13;
&#13;
# Validate Range&#13;
if (Range):&#13;
	if (len(Range) != 2):&#13;
		print '&lt;result&gt;Error: Range requires two values&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		Range[0] = rationalise_version(Range[0])&#13;
		if (Range[0] == ''):&#13;
			print '&lt;result&gt;Error: Range minimum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		Range[1] = rationalise_version(Range[1])&#13;
		if (Range[1] == ''):&#13;
			print '&lt;result&gt;Error: Range maximum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (compare_versions(Range[0], Range[1]) != 'Older'):&#13;
			print '&lt;result&gt;Error: Range minimum is greater than maximum&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (version_in_range(Version, Range) == False):&#13;
			print '&lt;result&gt;Error: Version is not within Range&lt;/result&gt;'&#13;
			exit(1)&#13;
&#13;
&#13;
# Check Installed Version(s)&#13;
Results = []&#13;
if (isfile(pdb)):&#13;
	# Query database for matching records&#13;
	Records = query_db_product(pdb, productName, payloadName)&#13;
	if (len(Records) == 0):&#13;
		Results.append('N/A')&#13;
	else:&#13;
		for i, Installed in enumerate(Records):&#13;
			Installed = rationalise_version(Installed)&#13;
			if (Installed == ''):&#13;
				Results.append('Error: Reading installed version')&#13;
			else:&#13;
				Results.append(compare_versions(Installed, Version))&#13;
			if (Range):&#13;
				if (version_in_range(Installed, Range) == False):&#13;
					Results[i] = 'N/A'&#13;
else:&#13;
	Results.append('N/A')&#13;
&#13;
if (len(Results) == 1):&#13;
	Result = Results[0]&#13;
elif ('Newer' in Results):&#13;
	Result = 'Newer'&#13;
elif ('Equal' in Results):&#13;
	Result = 'Equal'&#13;
elif ('Older' in Results):&#13;
	Result = 'Older'&#13;
elif ('N/A' in Results):&#13;
	Result = 'N/A'&#13;
else:&#13;
	Result = 'Error: Reading installed version'&#13;
&#13;
# Output Result&#13;
print '&lt;result&gt;' + Result + '&lt;/result&gt;'&#13;
exit(0)&#13;
</scriptContentsMac>
<scriptContentsWindows/>
</extensionAttribute>
