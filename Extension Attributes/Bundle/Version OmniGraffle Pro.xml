<?xml version="1.0" encoding="UTF-8"?>
<extensionAttribute>
<displayName>Version OmniGraffle Pro</displayName>
<description>Determines if a product is at least a specified Version by searching for bundles with a specific CFBundleIdentifier and Version.</description>
<dataType>string</dataType>
<scriptContentsMac>#!/usr/bin/python&#13;
&#13;
"""&#13;
Determines if a product is at least a specified Version by searching for bundles with a specific CFBundleIdentifier and Version.&#13;
The Key in the product bundle's Info.plist file may be specified to obtain the product's version.&#13;
Typically the Key is 'CFBundleShortVersionString' or 'CFBundleVersion', although a custom Key may be specified.&#13;
Results may (optionally) be limited to a range, when the CFBundleIdentifier is used for multiple major releases of the product.&#13;
A default path for the bundle may (optionally) be explicitly specified to check. Recommended as a fallback when Spotlight is disabled.&#13;
Returns 'Older' if an older version of the product is found.&#13;
Returns 'Equal' if the same version of a product is found.&#13;
Returns 'Newer' if a newer version of the product is found.&#13;
Returns 'N/A' if the product is not found.&#13;
"""&#13;
&#13;
# CFBundleIdentifier to search for [required]&#13;
CFBundleIdentifier = 'com.omnigroup.OmniGrafflePro'&#13;
# Key in plist to read version string from [required]&#13;
Key = 'CFBundleShortVersionString'&#13;
# Version to test for [required]&#13;
Version = '5.4.2'&#13;
# Range limit for bundle version [optional]&#13;
# Range = ['MIN', 'MAX']&#13;
# Default path for bundle [recommended]&#13;
Default = '/Applications/OmniGraffle Professional 5.app'&#13;
&#13;
# Required modules&#13;
from os import devnull&#13;
from os.path import exists, isabs, isfile&#13;
from pkg_resources import parse_version&#13;
from re import sub&#13;
from subprocess import check_output&#13;
&#13;
# Read Key's Value as String from Plist&#13;
def read_plist(p, k):&#13;
	with open(devnull, 'w') as DEVNULL:&#13;
		try:&#13;
			v = check_output(['/usr/bin/defaults', 'read', p, k], stderr=DEVNULL).rstrip()&#13;
		except:&#13;
			v = ''&#13;
	return v&#13;
&#13;
# Rationalise Version String&#13;
def rationalise_version(v):&#13;
	# Convert to lowercase&#13;
	v = v.lower()&#13;
	# Remove leading non-numeric characters&#13;
	v = sub('^[^0-9]*', '', v)&#13;
	# Remove trailing spaces&#13;
	v = sub(' *$', '', v)&#13;
	# Replace commas with periods&#13;
	v = sub(',', '.', v)&#13;
	# Remove 'dodgy' characters&#13;
	v = sub('[^a-z0-9 .-]', '', v)&#13;
	return v&#13;
&#13;
# Compare Version Strings&#13;
def compare_versions(v1, v2):&#13;
	if (parse_version(v1) &lt; parse_version(v2)):&#13;
		r = 'Older'&#13;
	elif (parse_version(v1) == parse_version(v2)):&#13;
		r = 'Equal'&#13;
	elif (parse_version(v1) &gt; parse_version(v2)):&#13;
		r = 'Newer'&#13;
	return r&#13;
&#13;
# Version in Range&#13;
def version_in_range(v, r):&#13;
	r = parse_version(r[1]) &gt; parse_version(v) &gt;= parse_version(r[0])&#13;
	return r&#13;
&#13;
# Find Bundles with identifier&#13;
def find_bundles(id):&#13;
	r = check_output(['/usr/bin/mdfind', 'kMDItemCFBundleIdentifier', '=', '"' + id + '"']).strip().split('\n')&#13;
	r = filter(lambda a: a != '', r)&#13;
	return r&#13;
&#13;
# Initialise variables&#13;
try:&#13;
	CFBundleIdentifier&#13;
except:&#13;
	print '&lt;result&gt;Error: CFBundleIdentifier not defined&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Key&#13;
except:&#13;
	print '&lt;result&gt;Error: No Key specified&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Version&#13;
except:&#13;
	print '&lt;result&gt;Error: No Version specified&lt;/result&gt;'&#13;
	exit(1)&#13;
try:&#13;
	Range&#13;
except:&#13;
	Range = None&#13;
try:&#13;
	Default&#13;
except:&#13;
	Default = None&#13;
&#13;
&#13;
# Validate Version&#13;
Version = rationalise_version(Version)&#13;
if (Version == ''):&#13;
	print '&lt;result&gt;Error: Version is invalid&lt;/result&gt;'&#13;
	exit(1)&#13;
&#13;
# Validate Range&#13;
if (Range):&#13;
	if (len(Range) != 2):&#13;
		print '&lt;result&gt;Error: Range requires two values&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		Range[0] = rationalise_version(Range[0])&#13;
		if (Range[0] == ''):&#13;
			print '&lt;result&gt;Error: Range minimum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		Range[1] = rationalise_version(Range[1])&#13;
		if (Range[1] == ''):&#13;
			print '&lt;result&gt;Error: Range maximum is invalid&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (compare_versions(Range[0], Range[1]) != 'Older'):&#13;
			print '&lt;result&gt;Error: Range minimum is greater than maximum&lt;/result&gt;'&#13;
			exit(1)&#13;
		if (version_in_range(Version, Range) == False):&#13;
			print '&lt;result&gt;Error: Version is not within Range&lt;/result&gt;'&#13;
			exit(1)&#13;
&#13;
# Validate Default&#13;
if (Default):&#13;
	if (not isabs(Default)):&#13;
		print '&lt;result&gt;Error: Default path is invalid&lt;/result&gt;'&#13;
		exit(1)&#13;
&#13;
# Initialise array for Bundles&#13;
Bundles = []&#13;
# Test Default path, add bundle to array if it exists&#13;
if (Default):&#13;
	if (exists(Default)): Bundles.append(Default)&#13;
# Search for bundles and add to array&#13;
for Bundle in find_bundles(CFBundleIdentifier):&#13;
	if (not Bundle in Bundles): Bundles.append(Bundle)&#13;
&#13;
# If we have no results check Spotlight status&#13;
if (len(Bundles) == 0):&#13;
	mdStatus = check_output(['/usr/bin/mdutil', '-s', '/'])&#13;
	# If Spotlight is disabled exit here to avoid a false result&#13;
	if 'disabled' in mdStatus:&#13;
		print '&lt;result&gt;Error: Spotlight is disabled&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		print '&lt;result&gt;N/A&lt;/result&gt;'&#13;
		exit(0)&#13;
else:&#13;
	# Initialise array for Plists&#13;
	Plists = []&#13;
	# Check default location(s) for plist in bundle(s)&#13;
	for Bundle in Bundles:&#13;
		if (isfile(Bundle + '/Contents/Info.plist')):&#13;
			Plists.append(Bundle + '/Contents/Info.plist')&#13;
		elif (isfile(Bundle + '/Resources/Info.plist')):&#13;
			Plists.append(Bundle + '/Resources/Info.plist')&#13;
	# If no plist(s), exit here&#13;
	if (len(Plists) == 0):&#13;
		print '&lt;result&gt;Error: Info.plist not in bundle(s)&lt;/result&gt;'&#13;
		exit(1)&#13;
	else:&#13;
		# Initialise array for Results&#13;
		Results = []&#13;
		# Check version in plist(s)&#13;
		for i, Plist in enumerate(Plists):&#13;
			# Read version from key in plist&#13;
			Installed = read_plist(Plist, Key)&#13;
			# Rationalise the version string for comparison&#13;
			Installed = rationalise_version(Installed)&#13;
			if (Installed == ''):&#13;
				# If we get an empty string for the version add error message&#13;
				Results.append('Error: Reading installed version')&#13;
			else:&#13;
				# Compare our versions and append to array&#13;
				Results.append(compare_versions(Installed, Version))&#13;
				if (Range):&#13;
					# If the installed version is outside of the range, update the entry in the array&#13;
					if (version_in_range(Installed, Range) == False):&#13;
						Results[i] = 'N/A'&#13;
&#13;
		# Prioritise our results&#13;
		if (len(Results) == 1):&#13;
			Result = Results[0]&#13;
		elif ('Newer' in Results):&#13;
			Result = 'Newer'&#13;
		elif ('Equal' in Results):&#13;
			Result = 'Equal'&#13;
		elif ('Older' in Results):&#13;
			Result = 'Older'&#13;
		elif ('N/A' in Results):&#13;
			Result = 'N/A'&#13;
		else:&#13;
			Result = 'Error: Reading installed version'&#13;
&#13;
		# Output final result&#13;
		print '&lt;result&gt;' + Result + '&lt;/result&gt;'&#13;
		exit(0)</scriptContentsMac>
<scriptContentsWindows/>
</extensionAttribute>
